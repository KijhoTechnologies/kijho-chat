{% extends 'ChatBundle:Default:mainAdmin.html.twig' %}
{% block title %}Chat Bundle - Admin{% endblock %}
{% block content %}

    {#<div class="main-content">
        <div class="row">
            <!-- Raw Links -->
            <div class="col-md-6 pull-right">
                <ul class="list-inline links-list ">
                    <li>
                        <a id="display-chat" href="#" data-toggle="chat" data-animate="1" data-collapse-sidebar="1">
                            <i class="entypo-chat"></i>
                            Chat
                            <span class="badge badge-success chat-notifications-badge is-hidden">0</span>
                        </a>
                    </li>
                </ul>
                <span id="container-notification"></span>
            </div>
        </div>
        <hr />
        <div class="col-lg-12" style="height: 400px; min-height: 400px;">    
        </div>
    </div>#}

    <div id="chat" class="fixed" data-current-user="{{nickname}}" data-order-by-status="1" data-max-chat-history="25">
        <div class="chat-inner">
            <h2 class="chat-header">
                <a href="#" class="chat-close" data-animate="1"><i class="entypo-cancel"></i></a>
                <i class="entypo-users"></i>Chat<span class="badge badge-success is-hidden">0</span>
            </h2>
            
            <span class="col-xs-12" id="container-notification"></span>
            <div class="col-xs-12" id="container-server-start" style="display: none;">
                <p>Chat server offline.</p>
                <a class="btn btn-success btn-md start-gos-server">Click To Start Chat Server</a>
            </div>

            <div class="chat-group" id="group-2">
                <strong>All Chats</strong>
                {% for conversation in lastConversations %}
                    <a href="#" class="open-client-conversation" client-id="{{conversation.senderId}}" data-conversation-history="#client-{{conversation.senderId}}"><span class="user-status is-offline"></span> <em>{{conversation.senderNickname}}</em> <span class="typing hidden pull-right"><i>Typing...</i></span></a>
                {% else %}
                    <a class="disabled" href="return false;">No chat history.</a>
                {% endfor %}
            </div>
        </div>

        <!-- conversation template -->
        <div class="chat-conversation">
            <div class="conversation-header">
                <a href="#" class="conversation-close"><i class="entypo-cancel"></i></a>

                <span class="user-status"></span>
                <span class="display-name"></span> 
                <small></small>
            </div>

            <ul class="conversation-body">	
            </ul>

            <div class="chat-textarea">
                <textarea class="form-control autogrow" placeholder="Type your message"></textarea>
            </div>
        </div>
    </div>

    <!-- Chat Histories -->
    <div class="container-chats">
        {% for clientConversation in allConversations %}
            <ul class="chat-history" id="client-{{clientConversation.data.senderId}}">
                {% for message in clientConversation.messages %}
                    {% set userClass = 'opponent' %}
                    {% if message.senderId == userId %}
                        {% set userClass = 'user' %}
                    {% endif %}
                    {% set readClass = '' %}
                    {% if message.readed == false and message.type == constant('Kijho\\ChatBundle\\Entity\\Message::TYPE_CLIENT_TO_ADMIN') %}
                        {% set readClass = 'unread' %}
                    {% endif %}
                    <li class="{{userClass~' '~readClass}}">
                        <span class="user">{{message.senderNickname}}</span>
                        <p>{{message.message}}</p>
                        <span class="time">{{message.date|date('m/d/Y h:i a')}}</span>
                    </li>
                {% endfor %}

                {#<li class="opponent unread">
                    <span class="user">Daniel A. Pena</span>
                    <p>I am going out.</p>
                    <span class="time">08:21</span>
                </li>#}
            </ul>
        {% endfor %}
    </div>

{% endblock %}

{% block scripts %}
    {# Damos click en este boton para desplegar el panel #}
    $("#display-chat").trigger('click');

    {# Ejecutamos una funcion periodicamente para verificar el estado del servidor #}
    window.setInterval(verifyServerConnection, 4000);

    $(".start-gos-server").click(function () {
    $(this).html('Please wait..');
    $.ajax({
    type: 'POST',
    url: "{{path('chat_start_gos_server')}}",
    dataType: 'json',
    timeout: 4000,
    success: function (r)
    {
    window.location.reload();
    },
    error: function (r)
    {
    window.location.reload();
    }
    });
    });
{% endblock %}

{% block other_scripts %}
    {{ ws_client() }}

    <script type = "text/javascript" >
        var _WS_URI = "ws://{{ gos_web_socket_server_host }}:{{ gos_web_socket_server_port }}";

        var webSocket = WS.connect(_WS_URI);

        var successConnect = false;

        var globalSession = null;

        webSocket.on("socket/connect", function (session) {
            bindUI(session);
            console.log("Successfully Connected!");
            successConnect = true;
            updateConnectionData(session)
            joinChatRoom(session);
        });

        webSocket.on("socket/disconnect", function (error) {
            console.log("Disconnected for " + error.reason + " with code " + error.code);
            successConnect = false;
            unbindUI();
        });

        /*Permite cambiar el nickname del usuario*/
        function updateConnectionData(session)
        {
            session.call("rpc/update_connection_data", {"nickname": "{{nickname}}", "user_id": "{{userId}}", "user_type": "{{userType}}"}).then(
                    function (result) {
                        console.log("RPC Valid!", result);
                    },
                    function (error, desc) {
                        console.log("RPC Error", error, desc);
                    }
            );
        }

        var messageToClient = '';
        // Permite habilitar los eventos sobre los botones de la ventana, cuando hay conexion
        function bindUI(session) {
            globalSession = session;
            $(".chat-textarea textarea").bind("keyup", function (e) {
                var key;
                if (window.event) {
                    key = window.event.keyCode;   /*IE*/
                } else {
                    key = e.which;                /*firefox*/
                }
                if ($('.chat-textarea textarea').val() != '') {
                    messageToClient = $('.chat-textarea textarea').val();
                }
                if (key == 13) {
                    sendMessage(session);
                }
            });

            $(".chat-inner").on("click", ".open-client-conversation", function () {
                var clientId = $(this).attr('client-id');
                prepareToMessage(clientId);
                putMessagesReaded(session, clientId);
            });
        }



        // Permite deshabilitar los eventos sobre los botones, cuando se pierde la conexion
        function unbindUI() {
            globalSession = null;
            $(".chat-textarea textarea").unbind();
            $(".open-client-conversation").unbind();
        }

        //permite realizar la conexion a una sala en especifico, y establecer un escucha de eventos
        function joinChatRoom(session) {
            //the callback function in "subscribe" is called everytime an event is published in that channel.
            session.subscribe("{{constant('Kijho\\ChatBundle\\Topic\\ChatTopic::CHAT_CHANNEL')}}", serverEvent);
        }

        /**
         * Esta funcion permite setear el id del cliente en el texarea 
         * para enviar mensajes, cuando el usuario abre una ventana de chat
         * @param {string} clientId identficador del cliente
         **/
        function prepareToMessage(clientId) {
            $(".chat-textarea textarea").attr('destination-id', clientId);
        }

        /**
         * Permite enviar un mensaje a alguno de los clientes
         * @param {type} session
         * @returns {undefined}
         */
        function sendMessage(session) {
            var textarea = $('.chat-textarea textarea');
            var clientId = textarea.attr('destination-id') + "";

            var nofityOtherAdmins = false;
            if (typeof adminDestinations[clientId] != 'undefined') {
                if (adminDestinations[clientId] == "{{constant('Kijho\\ChatBundle\\Topic\\ChatTopic::MESSAGE_ALL_ADMINISTRATORS')}}") {
                    nofityOtherAdmins = true;
                }
            }

            if (clientId != '' && clientId != 'undefined' && messageToClient != '') {
                var data = {type: "{{constant('Kijho\\ChatBundle\\Topic\\ChatTopic::MESSAGE_TO_CLIENT')}}",
                    clientId: clientId,
                    message: messageToClient,
                    notifyOtherAdmins: nofityOtherAdmins
                };
                session.publish("{{constant('Kijho\\ChatBundle\\Topic\\ChatTopic::CHAT_CHANNEL')}}", data);
                messageToClient = '';
            }
        }

        /**
         * Es la funcion que escucha los eventos del servidor 
         * @param {type} uri
         * @param {type} payload
         * @returns {undefined}
         */
        function serverEvent(uri, payload) {

            if (payload.msg_type == "{{constant('Kijho\\ChatBundle\\Topic\\ChatTopic::SERVER_WELCOME_MESSAGE')}}") {
                displayNotification(payload.msg);
            } else if (payload.msg_type == "{{constant('Kijho\\ChatBundle\\Topic\\ChatTopic::MESSAGE_FROM_CLIENT')}}") {
                messageFromClient(payload);
            } else if (payload.msg_type == "{{constant('Kijho\\ChatBundle\\Topic\\ChatTopic::SERVER_ONLINE_USERS')}}") {
                refreshOnlineUsers(payload.online_users);
            } else if (payload.msg_type == "{{constant('Kijho\\ChatBundle\\Topic\\ChatTopic::SERVER_NEW_CLIENT_CONNECTION')}}") {
                clientJoinRoom(payload);
            } else if (payload.msg_type == "{{constant('Kijho\\ChatBundle\\Topic\\ChatTopic::SERVER_CLIENT_LEFT_ROOM')}}") {
                clientLeftRoom(payload);
            } else if (payload.msg_type == "{{constant('Kijho\\ChatBundle\\Topic\\ChatTopic::MESSAGE_SEND_SUCCESSFULLY')}}") {
                displayNotification('Message send successfully');
            } else if (payload.msg_type == "{{constant('Kijho\\ChatBundle\\Topic\\ChatTopic::CLIENT_TYPING')}}") {
                clientTyping(payload);
            }
        }

        /**
         * Permite pintar el listado de usuarios conectados
         * @param {string} onlineUsers
         **/
        function refreshOnlineUsers(onlineUsers) {
            //verificamos si los online estan en el listado de conversaciones para ponerlos online (verde)
            for (i = 0; i < onlineUsers.length; i++) {
                var element = $("#group-2 a[client-id='" + onlineUsers[i]['user_id'] + "']");
                if (!$.isEmptyObject(element.html())) {
                    var spanStatus = $("#group-2 a[client-id='" + onlineUsers[i]['user_id'] + "'] span").first();
                    spanStatus.attr('class', 'user-status is-online');
                } else {
                    clientJoinRoom(onlineUsers[i]);
                }
            }
            neonChat.orderGroups();
        }

        /**
         * Permite realizar acciones en pantalla cuando un cliente
         * sale del chat 
         * @param {type} payload
         **/
        function clientLeftRoom(payload) {
            var element = $("#group-2 a[client-id='" + payload.user_id + "']");
            if (!$.isEmptyObject(element.html())) {
                var spanStatus = $("#group-2 a[client-id='" + payload.user_id + "'] span").first();
                spanStatus.attr('class', 'user-status is-offline');
            }
            //neonChat.refreshUserIds();
            neonChat.orderGroups();
            displayNotification(payload.msg);
        }

        /**
         * Permite realizar acciones en pantalla cuando un cliente
         * se conecta al chat
         * @param {type} payload
         **/
        function clientJoinRoom(payload) {
            var element = $("#group-2 a[client-id='" + payload.user_id + "']");
            if (!$.isEmptyObject(element.html())) {
                var spanStatus = $("#group-2 a[client-id='" + payload.user_id + "'] span").first();
                spanStatus.attr('class', 'user-status is-online');
            } else {
                var htmlUser = '<a href="#" class="open-client-conversation" client-id="' + payload.user_id + '" data-conversation-history="#client-' + payload.user_id + '"><span class="user-status is-online"></span> <em>' + payload.nickname + '</em><span class="badge badge-info is-hidden">0</span></a>';
                var firstUser = $('#group-2 a').first();
                if (firstUser.hasClass('disabled')) {
                    firstUser.remove();
                    $('#group-2').append(htmlUser);
                } else {
                    $('#group-2 a').first().before(htmlUser);
                }
            }
            //neonChat.refreshUserIds();
            neonChat.orderGroups();
            if (payload.msg) {
                displayNotification(payload.msg);
            }
        }

        /**
         * Permite verificar el estado del servidor gos para ocultar o mostrar 
         * el boton de inicio manual del servidor
         */
        function verifyServerConnection() {
            if (successConnect) {
                $('#container-server-start').css('display', 'none');
            } else {
                $('#container-server-start').css('display', '');
                displayNotification('Chat server is offline, please start manually');
            }
        }

        /**
         * Permite marcar los mensajes de un cliente como leidos
         * @param {string} clientId identificador del cliente
         **/
        function putMessagesReaded(session, clientId) {
            if (clientId != '') {
                var data = {type: "{{constant('Kijho\\ChatBundle\\Topic\\ChatTopic::PUT_MESSAGES_AS_READED')}}",
                    clientId: clientId,
                };
                session.publish("{{constant('Kijho\\ChatBundle\\Topic\\ChatTopic::CHAT_CHANNEL')}}", data);

                var chatContainer = $("#client-" + clientId);
                chatContainer.find('li.unread').removeClass('unread');
            }
        }

        /**
         * En este arreglo se guardan bajo los ids de los clientes, el destino
         * que tenia el mensaje, puede estar dirigido al admin actual o a todos los admins
         * este arreglo es necesario para notificar a los demas admins cuando un admin
         * toma la conersacion con un cliente
         * @type Array         
         **/
        var adminDestinations = [];

        /**
         * Permite realizar acciones en pantalla cuando llega un mensaje de un cliente
         * @param {type} payload
         **/
        function messageFromClient(payload) {

            displayNotification('New message from '+ payload.nickname);

            adminDestinations[payload.user_id] = payload.admin_destination;

            //buscamos el tab de conversacion del usuario en el listado de conversaciones
            var element = $(".open-client-conversation[client-id='" + payload.user_id + "']");
            if (!$.isEmptyObject(element.html())) {
                increaseUnreadCounters(element);

                //armamos el html con el mensaje del usuario
                var htmlMessage = '<li class="opponent unread">';

                if (payload.admin_destination == "{{constant('Kijho\\ChatBundle\\Topic\\ChatTopic::MESSAGE_ALL_ADMINISTRATORS')}}") {
                    htmlMessage += '<span class="user pull-left">' + payload.nickname + ' <i class="pull-right">(Waiting for and Admin Response)</i></span>';
                } else {
                    htmlMessage += '<span class="user">' + payload.nickname + '</span>';
                }
                htmlMessage += '<p>' + payload.msg + '</p>'
                        + '<span class="time">' + payload.msg_date + '</span>'
                        + '</li>';

                //buscamos el panel de mensajes del usuario
                var chatContainer = $("#client-" + payload.user_id);
                if (!$.isEmptyObject(chatContainer.html())) {
                    chatContainer.append(htmlMessage);
                } else {
                    //si no habia un panel de mensajes para el usuario, le creamos uno
                    var html = '<ul class="chat-history" id="client-' + payload.user_id + '">'
                            + htmlMessage + '</ul>';
                    $(".container-chats").append(html);
                }

                neonChat.prefetchMessages();

                //verificamos si la ventana de chat esta abierta
                var display = $('.chat-conversation').css('display');
                if (display == 'block') {
                    //si esta abierta preguntamos si el mensaje entrante es del chat abierto
                    var userId = $(".chat-conversation div.chat-textarea textarea.form-control").attr('destination-id');
                    if (userId == payload.user_id) {
                        //debemos marcar los mensajes como leidos
                        if (globalSession) {
                            //ocultar el icono de unread
                            putMessagesReaded(globalSession, payload.user_id);
                            neonChat.prefetchMessages();

                            neonChat.resetUnreads(element.attr('id'));
                            neonChat.puffUnreadsAll();

                        }
                        neonChat.renderMessages(neonChat.$current_user.attr('id'));

                    }
                }


            }

        }

        /**
         * Permite incrementar los contadores de mensajes no leidos
         * cuando un cliente envia un nuevo mensaje
         * @param {type} element
         **/
        function increaseUnreadCounters(element) {
            //buscamos el span para aumentar los mensajes sin leer del usuario
            var span = element.find("span.badge");
            var unreadMessages = parseInt(span.text());
            if (unreadMessages == 0) {
                span.removeClass('is-hidden');
            }
            span.text(unreadMessages + 1);

            //buscamos el span para aumentar los mensajes sin leer de todos los usuarios
            var generalSpan = $(".chat-header span.badge");
            var unreadMessages = parseInt(generalSpan.text());
            if (unreadMessages == 0) {
                generalSpan.removeClass('is-hidden');
            }
            generalSpan.text(unreadMessages + 1);
        }


        function clientTyping(payload) {
            var tabConversation = $(".open-client-conversation[client-id='" + payload.user_id + "']");
            tabConversation.find("span.typing").removeClass('hidden');
            window.setTimeout(hideTyping, 2000);
        }

        function displayNotification(msg) {
            $("#container-notification").html(msg);
            $("#container-notification").removeClass('hidden');
            window.setTimeout(hideNotification, 2000);
        }

        function hideNotification() {
            var object = $("#container-notification");
            if (!object.hasClass('hidden')) {
                object.addClass('hidden');
            }
        }


        function hideTyping() {
            $(".open-client-conversation span.typing").each(function () {
                var object = $(this);
                if (!object.hasClass('hidden')) {
                    object.addClass('hidden');
                }
            });
        }


    </script>
{% endblock %}